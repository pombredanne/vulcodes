{
    "identifier": "CVE-2016-2177",
    "summary": "Avoid some undefined pointer arithmetic A common idiom in the codebase is to check limits in the following manner: \"p + len > limit\" Where \"p\" points to some malloc'd data of SIZE bytes and limit == p + SIZE \"len\" here could be from some externally supplied data (e.g. from a TLS message). The rules of C pointer arithmetic are such that \"p + len\" is only well defined where len <= SIZE. Therefore the above idiom is actually undefined behaviour. For example this could cause problems if some malloc implementation provides an address for \"p\" such that \"p + len\" actually overflows for values of len that are too big and therefore p + len < limit.",
    "references": [],
    "vulnerable_packages": [
        "pkg:generic/openssl@1.0.1p",
        "pkg:generic/openssl@1.0.1k",
        "pkg:generic/openssl@1.0.1b",
        "pkg:generic/openssl@1.0.1o",
        "pkg:generic/openssl@1.0.1c",
        "pkg:generic/openssl@1.0.2g",
        "pkg:generic/openssl@1.0.1s",
        "pkg:generic/openssl@1.0.1e",
        "pkg:generic/openssl@1.0.1d",
        "pkg:generic/openssl@1.0.2d",
        "pkg:generic/openssl@1.0.2h",
        "pkg:generic/openssl@1.0.1",
        "pkg:generic/openssl@1.0.2e",
        "pkg:generic/openssl@1.0.1g",
        "pkg:generic/openssl@1.0.2c",
        "pkg:generic/openssl@1.0.1n",
        "pkg:generic/openssl@1.0.1m",
        "pkg:generic/openssl@1.0.1a",
        "pkg:generic/openssl@1.0.2b",
        "pkg:generic/openssl@1.0.2",
        "pkg:generic/openssl@1.0.1i",
        "pkg:generic/openssl@1.0.1r",
        "pkg:generic/openssl@1.0.1q",
        "pkg:generic/openssl@1.0.1f",
        "pkg:generic/openssl@1.0.1j",
        "pkg:generic/openssl@1.0.2f",
        "pkg:generic/openssl@1.0.2a",
        "pkg:generic/openssl@1.0.1l",
        "pkg:generic/openssl@1.0.1t",
        "pkg:generic/openssl@1.0.1h"
    ],
    "resolved_packages": [
        "pkg:generic/openssl@1.0.2i",
        "pkg:generic/openssl@1.0.1u"
    ]
}